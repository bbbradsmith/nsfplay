#pragma once
#ifndef __CORE_PCH__
#define __CORE_PCH__
// core.h
//   All internal core shared functions and data should be defined here.
//   Most modules can define their interface functions here,
//   preferring one central header over individual module headers,
//   but modules with a state struct (audio units, etc.)
//   may have their own header included here.
//
//   core.h should be included as the first code line in every core source file.
//   Some builds will force-include it as a precompiled header.
//   The include guards allow GCC to use the precompiled version in another directory
//   without redundantly including this one.

#include <nsfplaycore.h>
#include <stddef.h> // NULL

typedef int8_t    sint8;
typedef int16_t   sint16;
typedef int32_t   sint32;
typedef int64_t   sint64;

typedef uint8_t   uint8;
typedef uint16_t  uint16;
typedef uint32_t  uint32;
typedef uint64_t  uint64;

#ifndef NSF_NOTEXT
	// define NSF_NOTEXT=1 to strip all unnecessary text from the build
	//   this disables ini parsing and key lookup
	//   error messages and keys will become blank strings
	//   error codes can still be used to disambiguate errors
	//   shift-jis decoding will be disabled
	#define NSF_NOTEXT 0
#endif

#ifndef NSF_MUTEX
	// define NSF_MUTEX=1 to add thread safety mutexing for the entire public nsfplaycore interface,
	// though NSFCore's own internal interface will not receive any such protection
	#define NSF_MUTEX 0
#endif

//
// Common macros for internal use
//
// SETTING, PROP, and PROPS skip the need for the NSF_SET_/NSF_PROP_ prefixes when reading settings or props.
//
// NSF_DEBUG is a printf to the debug message callback (printf to stdout by default), only in DEBUG builds
// NSF_ASSERT is a fatal error if a condition is false, with a diagnostic message, only in DEBUG builds
// NSF_DEBUG_ALLOC tracks simple allocation statistics and prints them to NSF_DEBUG, only in DEBUG builds
// NSF_RASSERT is like NSF_ASSERT but applies to all builds,
//   use this only for unrecoverable errors that should not be possible to generate through the public nsfplaycore interface
// NSF_UNUSED suppresses the unused parameter/variable warnings generated by some compilers
//

// convenient accessors
#define SETTING(setenum_) (setting[NSF_SET_##setenum_])
#define PROP(propenum_) (prop_int(NSF_PROP_##propenum_))
#define PROPS(propenum_) (prop_str(NSF_PROP_##propenum_))

#define NSF_ASSERT_MSG(msg_,condition_,line_) "Assert: " msg_ " (" #condition_ ") at " __FILE__ ":" #line_

#ifdef DEBUG
	#define NSF_DEBUG(...) { nsf::debug_printf(__VA_ARGS__); }
	#define NSF_ASSERT(condition_,msg_) { if (!(condition_)) nsf::assert(NSF_ASSERT_MSG(condition_,__LINE__),(msg_)); }
	#define NSF_DEBUG_ALLOC 1
#else
	#define NSF_DEBUG(...) {}
	#define NSF_ASSERT(condition_,msg_,...) {}
	#define NSF_DEBUG_ALLOC 0
#endif

// release assert
#if !NSF_NOTEXT
	#define NSF_RASSERT(condition_,msg_) { if (!(condition_)) nsf::assert(NSF_ASSERT_MSG(condition_,__LINE__,msg_); }
#else
	#define NSF_RASSERT(condition_msg_) { if (!(condition_)) nsf::assert("Assert!",NULL); }
#endif

#define NSF_UNUSED(variable_) {(void)(variable_);}

//
// NSFCore structure, code members defined in core.cpp unless otherwised marked
//

typedef struct NSFCore_
{
	// core state

	// general rule of thumb:
	//   Try not to store unnecessary state.
	//   Use a setting directly instead of copying it, where possible.
	//   Use prop to look up instead of store values.
	//   Can make exceptions for performance:
	//     Volume applies per-cycle/sample, should store that with fixed point adjustments.
	//     Square phase reset only applies per emulated-write, just use the setting directly.
	//     Settings are fast, props are slow, but props are generally only needed at song start.
	//   Consider whether setting changes can apply immediately (and add to set_apply if they do).

	// text and error output buffers
	static const int ERROR_LAST_BUFFER_SIZE = 256;
	static const int TEMP_TEXT_SIZE = 1024;
	mutable const char* error_last;
	mutable sint32 error_last_code;
	mutable char error_last_buffer[ERROR_LAST_BUFFER_SIZE]; // error_last may point to this for formatted errors
	mutable char temp_text[TEMP_TEXT_SIZE]; // used for returned text information
	mutable const uint8* active_prop_lines;
	mutable uint32 active_prop_lines_len;

	// settings
	sint32 setting[NSF_SET_COUNT]; // integer settings (can read directly, write with set_int)
	const char* setting_str[NSF_SETSTR_COUNT]; // string settings, indexed by value in setting[], (use set/get_str to access)
	bool setting_str_free[NSF_SETSTR_COUNT]; // true if string setting was allocated (not default), managed by set_str/destroy

	// emulation
	const uint8* nsf;
	uint32 nsf_size;
	bool nsf_free; // true if nsf was allocated (load rather than assume)
	bool nsf_bin; // binary file at $6000 instead of NSF

	uint8 ram0000[0x00800-0x0000]; // $0000-07FF 2k of on-board RAM
	uint8 ram6000[0x10000-0x6000]; // $6000-FFFF 40k of RAM or other workspace
	const uint8* rom; // pointer to read only NSF data, aligned for padding (first/last banks may be masked by pad0/pad1)
	uint8* pad0; // 4k first bank, if it needs padding due to LOAD address (may reuse ram6000 at E000)
	uint8* pad1; // 4k last bank, if it needs padding due to not filling a complete bank (may reuse ram6000 at F000)
	unsigned int bank_last; // last bank in data (pad1 if not NULL)
	const uint8* rpage[16]; // currently assigned 4k bank pages for reading (null for open bus)
	uint8* wpage[16]; // currently assigned 4k bank pages for writing

	// playback
	uint8 active_song;

	// audio units
	// TODO these should be static POD structures, each with a pointer to the core
	// arrays for each:
	//   read function (flags resync if needed)
	//     probably need a read-sync stack (to sync before a read)
	//   write function (flags resync if needed)
	//     probably need a write-sync stack to sync before a write
	//     then do sync, then the write stack
	//   render function
	//   (these can have variants, e.g. render to aux buffer for side mixing)
	//   audio filters could go in the render stack, if okay to operate at high frequency

	// audio filters
	// TODO
	// stack of function pointers (allows processes to swap out, reorder) to operate at output frequency, after resample)

	// audio rendering
	// TODO
	// output buffer (32-bit), secondary output buffer (these can be small by default, might need more for direct emu drive instead of render out)
	// cycle buffer (32-bit), secondary (needs to be wide enough for resampling, but not any larger)
	// resample kernel
	//   maybe audio units can have a memory setup interface where each says how much it needs, then it's allocated, then the memory is handed out
	// resampler function pointer

	// interface

	static NSFCore* create();
	static void destroy(NSFCore* core); // Calls ->release before freeing the core.
	void release(); // internal: called by destroy, releases all owned allocations

	const char* last_error() const; // returns last error message, NULL if none since last check
	sint32 last_error_code() const; // returns last error message textenum, -1 if none since last check
	void set_error(sint32 textenum,...) const; // sets last error and generates error callback
	void set_ini_error(int linenum, sint32 textenum,...) const; // for ini files (-1 if no ini)
	void set_error_raw(const char* fmt,...) const; // set_error with localized errors is preferred, but this can send raw text errors for debug purposes
	static void global_error(sint32 textenum); // a global error with no core

	void set_default(); // restore default settings
	bool set_ini(const char* ini);
	bool set_init(const NSFSetInit* init, bool assume_str=false);
	bool set_int(sint32 setenum, sint32 value); // integer setting (sets error if false)
	bool set_str(sint32 setenum, const char* value, bool assume=false, sint32 len=-1); // string setting, assume treats value as permanent (no copy), len truncates (if assume=false), len<0 will strlen (sets error if false)
	void set_apply(); // call to apply changed settings now
	sint32 get_int(sint32 setenum) const;
	const char* get_str(sint32 setenum) const; // use this instead of manually de-indexing setting_str

	static sint32 set_enum(const char* key, int len=-1); // len truncates, len<0 uses strlen
	static sint32 group_enum(const char* key, int len=-1);
	NSFSetInfo set_info(sint32 setenum) const;
	NSFGroupInfo group_info(sint32 group) const;

	const char* ini_line(sint32 setenum) const;
	bool ini_write(FILE* f) const; // use a "wt" file, writes with fprintf to generate native newlines, returns false if errors writing
	bool parse_ini_line(const char* line, int len, int linenum); // linenum=-1 to parse a line with no INI file context

	bool load(const uint8* data, uint32 size, bool assume=false, bool bin=false);

	NSFPropInfo prop_info(sint32 prop) const;
	NSFUnitInfo unit_info(sint32 unit) const;
	NSFChannelInfo channel_info(sint32 channel) const;

	const char* local_text(sint32 textenum) const; // NSF_TEXT_x for curent locale (local_text(0) is a default error string)
	static const char* local_text(sint32 textenum, sint32 locale); // NSF_TEXT_x for specific locale

	// nsf.cpp
	bool nsf_parse(bool bin);
	const uint8* nsfe_chunk(uint32 fourcc, uint32* chunk_size) const; // fourcc is packed little-endian into uint32
	const uint8* nsfe_chunk(const char* fourcc, uint32* chunk_size) const;
	bool prop_exists(sint32 prop, sint32 song=-1) const; // song<0 = active_song
	sint32 prop_int(sint32 prop, sint32 song=-1) const;
	sint64 prop_long(sint32 prop, sint32 song=-1) const;
	const char* prop_str(sint32 prop, sint32 song=-1) const;
	sint32 prop_lines(sint32 prop, sint32 song=-1) const;
	const char* prop_line() const;
	const uint8* prop_blob(uint32* blob_size, sint32 prop, sint32 song=-1) const;

} NSFCore;

namespace nsf {

// core.cpp

extern "C" {
extern void* (*custom_alloc)(size_t size);
extern void* (*custom_free)(void* ptr);
extern void (*error_callback)(const NSFCore* core, sint32 code, const char* msg);
extern void (*debug_print_callback)(const char* msg);
extern void (*fatal_callback)(const char* msg);
}

void* alloc(size_t size);
void free(void* ptr);
void debug_printf(const char* fmt,...); // only works if DEBUG defined
void debug(const char* msg);
void fatal(const char* msg);
void assert(const char* msg);

} // namespace nsf

#endif // __CORE_PCH__
